//! Flake function trait
use crate::{command::NixCmd, flake::url::FlakeUrl};
use lazy_static::lazy_static;
use serde::{Deserialize, Serialize};
use serde_json::Value;
use std::{
    env,
    ffi::OsString,
    os::unix::ffi::OsStringExt,
    path::{Path, PathBuf},
    process::Stdio,
};
use tokio::io::{AsyncBufReadExt, BufReader};

lazy_static! {
    static ref TRUE_FLAKE: FlakeUrl = {
        let path = env!("TRUE_FLAKE");
        Into::<FlakeUrl>::into(Path::new(path))
    };
    static ref FALSE_FLAKE: FlakeUrl = {
        let path = env!("FALSE_FLAKE");
        Into::<FlakeUrl>::into(Path::new(path))
    };
}

/// Trait for flake functions
pub trait FlakeFn {
    /// Input type, corresponding to flake inputs
    ///
    /// A field named `flake` will be treated special (extra args' --override-inputs operates on this flake)
    type Input;
    /// Output generated by building the flake fn
    type Output;

    /// Get the flake URL referencing this function
    fn flake() -> &'static FlakeUrl;

    /// Initialize the type after reading from Nix build
    fn init(_out: &mut Self::Output) {}

    /// Call the flake function, taking `Self::Input`, returning `Self::Output` along with the built store path output as `PathBuf`.
    ///
    /// The store path output can be useful for further processing, if you need it with its entire closure (for e.g., to `nix copy` everything in `Self::Output` at once).
    ///
    /// Arguments:
    /// - `nixcmd`: The Nix command to use
    /// - `verbose`: Whether to avoid the --override-input noise suppression.
    /// - `extra_args`: Extra arguments to pass to `nix build`. --override-input is treated specially, to account for the flake input named `flake` (as defined in `Self::Input`)
    /// - `input`: The input arguments to the flake function.
    fn call(
        nixcmd: &NixCmd,
        verbose: bool,
        // FIXME: Don't do this; instead take dyn trait options
        impure: bool,
        pwd: Option<&Path>,
        m_out_link: Option<&Path>,
        extra_args: Vec<String>,
        input: Self::Input,
    ) -> impl std::future::Future<Output = Result<(PathBuf, Self::Output), Error>> + Send
    where
        Self::Input: Serialize + Send + Sync,
        Self::Output: Sync + for<'de> Deserialize<'de>,
    {
        async move {
            let mut cmd = nixcmd.command();
            cmd.args(["build", Self::flake(), "-L", "--print-out-paths"]);

            if impure {
                cmd.arg("--impure");
            }

            if let Some(out_link) = m_out_link {
                cmd.arg("--out-link");
                cmd.arg(out_link);
            } else {
                cmd.arg("--no-link");
            }

            let input_vec = to_vec(&input);
            for (k, v) in input_vec {
                cmd.arg("--override-input");
                cmd.arg(k);
                cmd.arg(v);
            }

            cmd.args(transform_override_inputs(&extra_args));

            if let Some(pwd) = pwd {
                cmd.current_dir(pwd);
            }

            crate::command::trace_cmd(&cmd);

            let mut output_fut = cmd.stdout(Stdio::piped()).stderr(Stdio::piped()).spawn()?;
            let stderr_handle = output_fut.stderr.take().unwrap();
            tokio::spawn(async move {
                // Suppress --override-input noise, since we expect these to be present.
                let mut reader = BufReader::new(stderr_handle).lines();
                while let Some(line) = reader.next_line().await.expect("read stderr") {
                    if !verbose {
                        if line.starts_with("â€¢ Added input") {
                            // Consume the input logging itself
                            reader.next_line().await.expect("read stderr");
                            continue;
                        } else if line
                            .starts_with("warning: not writing modified lock file of flake")
                        {
                            continue;
                        }
                    }
                    eprintln!("{}", line);
                }
            });
            let output = output_fut.wait_with_output().await?;
            if output.status.success() {
                let store_path =
                    PathBuf::from(OsString::from_vec(output.stdout.trim_ascii_end().into()));
                let mut v: Self::Output =
                    serde_json::from_reader(std::fs::File::open(&store_path)?)?;
                Self::init(&mut v);
                Ok((store_path, v))
            } else {
                Err(Error::NixBuildFailed(output.status.code()))
            }
        }
    }
}

/// Transform `--override-input` arguments to use `flake/` prefix, which
/// devour_flake expects.
///
/// NOTE: This assumes that Input struct contains a field named exactly "flake" referring to the flake. We should probably be smart about this.
fn transform_override_inputs(args: &[String]) -> Vec<String> {
    let mut new_args = Vec::with_capacity(args.len());
    let mut iter = args.iter().peekable();

    while let Some(arg) = iter.next() {
        new_args.push(arg.clone());
        if arg == "--override-input" {
            if let Some(next_arg) = iter.next() {
                new_args.push(format!("flake/{}", next_arg));
            }
        }
    }

    new_args
}

/// Convert a struct of uniform value types (Option allowed, however) into a vector of fields. The value should be of String kind.
fn to_vec<T>(value: &T) -> Vec<(String, String)>
where
    T: Serialize,
{
    let map = serde_json::to_value(value)
        .unwrap()
        .as_object()
        .unwrap_or_else(|| panic!("Bad struct for FlakeFn"))
        .clone();

    map.into_iter()
        .filter_map(|(k, v)| match v {
            Value::String(s) => Some((k, s.to_string())),
            Value::Bool(b) => Some((
                k,
                if b {
                    TRUE_FLAKE.to_string()
                } else {
                    FALSE_FLAKE.to_string()
                }
                .to_string(),
            )),
            _ => None,
        })
        .collect()
}

/// Errors associated with `FlakeFn::call`
#[derive(thiserror::Error, Debug)]
pub enum Error {
    /// IO error
    #[error("IO error: {0}")]
    IOError(#[from] std::io::Error),

    /// Non-zero exit code
    #[error("`nix build` failed; exit code: {0:?}")]
    NixBuildFailed(Option<i32>),

    /// JSON error
    #[error("JSON error: {0}")]
    JSONError(#[from] serde_json::Error),
}
